<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Flow Matching and Continuous Normalizing Flows | Runze Tian </title> <meta name="author" content="R. Z. Tian"> <meta name="description" content="This post explores Flow-based Models, Continuous Normalizing Flows (CNFs), and Flow Matching (FM). We discuss Normalizing Flows, derive the conditional flow matching objective, and examine special instances including diffusion models and optimal transport."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/moonshot.png?ac494055d0715958a4a25e163d4405f7"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://gua927.github.io/blog/2025/Note-FM/"> <script src="/assets/js/theme.js?8a9658bcfd3c4d23968422c4b9dc98ec"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <script>
    window.MathJax = {
      tex: {
        tags: 'ams',
        inlineMath: [
          ['$', '$'],
          ['\\(', '\\)'],
        ],
        displayMath: [
          ['$$', '$$'],
          ['\\[', '\\]'],
        ],
        processEscapes: true,
        processEnvironments: true,
        processRefs: true,
        digits: /^(?:[0-9]+(?:\{,\}[0-9]{3})*(?:\.[0-9]*)?|\.[0-9]+)/,
        maxBuffer: 5 * 1024,
      },
      chtml: {
        scale: 1,
        minScale: 0.5,
        matchFontHeight: true,
        linebreaks: { automatic: false, width: 'container' },
      },
      startup: {
        pageReady: () => {
          return MathJax.startup.defaultPageReady().then(() => {
            console.log('MathJax typesetting complete');
          });
        },
      },
      options: {
        renderActions: {
          addCss: [
            200,
            function (doc) {
              const style = document.createElement('style');
              style.innerHTML = `
              .mjx-container { color: inherit; }
              mjx-container[display="true"] {
                overflow-x: auto; overflow-y: hidden; max-width: 100%;
              }
              mjx-container[display="true"]::-webkit-scrollbar { height: 6px; }
              mjx-container[display="true"]::-webkit-scrollbar-track {
                background: rgba(0,0,0,0.05); border-radius: 3px;
              }
              mjx-container[display="true"]::-webkit-scrollbar-thumb {
                background: rgba(0,0,0,0.2); border-radius: 3px;
              }
              mjx-container[display="true"]::-webkit-scrollbar-thumb:hover {
                background: rgba(0,0,0,0.3);
              }
            `;
              document.head.appendChild(style);
            },
            '',
          ],
        },
      },
    };
  </script> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Flow Matching and Continuous Normalizing Flows",
            "description": "This post explores Flow-based Models, Continuous Normalizing Flows (CNFs), and Flow Matching (FM). We discuss Normalizing Flows, derive the conditional flow matching objective, and examine special instances including diffusion models and optimal transport.",
            "published": "November 05, 2025",
            "authors": [
              
              {
                "author": "Runze Tian",
                "authorURL": "https://gua927.github.io",
                "affiliations": [
                  {
                    "name": "GenSI Lab, THU-AIR",
                    "url": "https://www.gensi-thuair.com/#/portal_home"
                  }
                ]
              }
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> Runze Tian </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link"><i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Flow Matching and Continuous Normalizing Flows</h1> <p>This post explores Flow-based Models, Continuous Normalizing Flows (CNFs), and Flow Matching (FM). We discuss Normalizing Flows, derive the conditional flow matching objective, and examine special instances including diffusion models and optimal transport.</p> </d-title> <d-byline></d-byline> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div> <a href="#overview">Overview</a> </div> <div> <a href="#normalizing-flows">Normalizing Flows</a> </div> <div> <a href="#expressive-power-of-flow-based-models">Expressive Power of Flow-Based Models</a> </div> <div> <a href="#continuous-normalizing-flows">Continuous Normalizing Flows</a> </div> <div> <a href="#flow-matching">Flow Matching</a> </div> <ul> <li> <a href="#continuity-equation">Continuity Equation</a> </li> <li> <a href="#conditional-and-marginal-probability-paths-and-vector-fields">Conditional and Marginal Probability Paths and Vector Fields</a> </li> <li> <a href="#conditional-flow-matching">Conditional Flow Matching</a> </li> <li> <a href="#calculate-conditional-probability-paths-and-conditional-vector-fields">Calculate Conditional Probability Paths and Conditional Vector Fields</a> </li> </ul> <div> <a href="#special-instances-of-gaussian-conditional-probability-paths">Special Instances of Gaussian Conditional Probability Paths</a> </div> <ul> <li> <a href="#diffusion-conditional-vfs">Diffusion conditional VFs</a> </li> <li> <a href="#optimal-transport-conditional-vfs">Optimal Transport conditional VFs</a> </li> </ul> </nav> </d-contents> <h2 id="overview">Overview</h2> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2025-11-5-Note-FM/figure1-480.webp 480w,/assets/img/posts/2025-11-5-Note-FM/figure1-800.webp 800w,/assets/img/posts/2025-11-5-Note-FM/figure1-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/posts/2025-11-5-Note-FM/figure1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><strong>Flow-based Models</strong> are generative models based on <strong>Normalizing Flows (NFs)</strong>, which transform complex probability distributions into simple ones through a series of probability density function transformations, and generate new data samples through inverse transformations. <strong>Continuous Normalizing Flows (CNFs)</strong> extend <strong>Normalizing Flows</strong> by using ordinary differential equations (<strong>ODEs</strong>) to represent continuous transformation processes for modeling probability distributions.</p> <p><strong>Flow Matching (FM)</strong> is a method for training <strong>Continuous Normalizing Flows</strong> that trains the model by learning <strong>Vector Fields</strong> associated with probability paths, and uses <strong>ODE</strong> solvers to generate new samples.</p> <p>Diffusion models are a special case of <strong>Flow Matching</strong> applications. Using FM can improve their training stability. Furthermore, constructing probability paths using <strong><em>Optimal Transport</em></strong> techniques can further accelerate training speed and enhance model generalization ability.</p> <h2 id="normalizing-flows">Normalizing Flows</h2> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2025-11-5-Note-FM/figure2-480.webp 480w,/assets/img/posts/2025-11-5-Note-FM/figure2-800.webp 800w,/assets/img/posts/2025-11-5-Note-FM/figure2-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/posts/2025-11-5-Note-FM/figure2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><strong>Normalizing Flows (NFs)</strong> are invertible probability density transformation methods whose core idea is to progressively transform a simple distribution (typically a Gaussian distribution) into a complex target distribution through a series of invertible transformation functions. <strong>This process can be viewed as an iterative sequence of variable substitutions, where each substitution follows the change of variables principle for probability density functions</strong>. Through this approach, <strong>Normalizing Flows</strong> can precisely compute the probability density of the transformed distribution, thereby achieving an exact mapping from simple to complex distributions.</p> <p>Let $p_0(\mathbf{z_0})$ be the original simple distribution (e.g., standard Gaussian distribution). <strong><em>Normalizing Flows</em></strong> aim to transform it into the target distribution $p(x)$ through a series of invertible transformations $f_i$. These transformations define a mapping from $z_0$ to $x$, and each transformation $f_i$ has its inverse transformation $f_i^{-1}$. Thus, the transformation process can be represented as:</p> \[x=z_K=f_K\circ f_{K-1}\circ\cdots\circ f_1(z_0)\] <p>For the $i$-th step, we have:</p> \[\mathbf{z}_{i-1} \sim p_{i-1}(\mathbf{z}_{i-1})\\ \mathbf{z}_i = f_i(\mathbf{z}_{i-1}), \quad \text{thus } \mathbf{z}_{i-1} = f_i^{-1}(\mathbf{z}_i)\] <p>According to the change of variables formula for probability density functions, we obtain:</p> \[\begin{align*} p_i(\mathbf{z}_i) &amp;= p_{i-1}(f_i^{-1}(\mathbf{z}_i)) \left| \det \left( \frac{d f_i^{-1}}{d \mathbf{z}_i} \right) \right|\\ &amp;= p_{i-1}(\mathbf{z}_{i-1}) \left| \det \left( \frac{d f_i}{d \mathbf{z}_{i-1}} \right)^{-1} \right|\\ &amp;= p_{i-1}(\mathbf{z}_{i-1}) \left| \det \left( \frac{d f_i}{d \mathbf{z}_{i-1}} \right) \right|^{-1} \end{align*}\] <p>The log-likelihood is given by:</p> \[\log p_i(x)=\log p_{i-1}(z_{K-1})-\log\bigg|\det\frac{df_i}{dz_{i-1}}\bigg|\] <p>Thus we have</p> \[\log p(x)=\log \pi_0(z_0)-\sum\limits_{i=1}^{K}\log\bigg|\det\frac{df_i}{dz_{i-1}} \bigg|\] <p>When this series of transformation functions $f_i$ are invertible and the Jacobian matrices are tractable to compute, during model training, the optimization objective is the negative log-likelihood:</p> \[\mathcal L(\mathcal D)=-\frac{1}{\mathcal D}\sum_{x\in\mathcal D}\log p(x)\] <h2 id="expressive-power-of-flow-based-models">Expressive Power of Flow-Based Models</h2> <p>We consider whether we can transform a simple distribution $p(u)$ into any arbitrary probability distribution $p(x)$. Assume $x$ is a $D$-dimensional vector with $p(x)&gt;0$, and the probability distribution of $x_i$ depends only on the previous elements $x_{1:i-1}$. Then we can decompose $p_x(x)$ as a product of conditional probabilities</p> \[p_x(x)=\prod_{i=1}^{D}p_x(x_i|x_{1:i-1})\] <p>Assume the transformation $F$ maps $x$ to $z$, where the value of $z_i$ is determined by the cumulative distribution function (CDF) of $x_i$</p> \[z_i=F_i(x_i,x_{1:i-1})=\int_{-\infty}^{x_i}p_x(x_i'|x_{1:i-1})dx'_i=P(x'_i\le x_i|x_{1:i-1})\] <p>Clearly, $F_i$ is differentiable, and its partial derivative with respect to $x_i$ equals $p_x(x_i|x_{1:i-1})$. Since the partial derivative of $F_i$ with respect to $x_j~(j&gt;i)$ is 0, $J_F(x)$ is a lower triangular matrix, and thus its determinant equals the product of its diagonal elements, i.e.,</p> \[\det J_F(x)=\prod_{i=1}^{D}\frac{\partial F_i}{\partial x_i}=\prod_{i=1}^{D}p_x(x_i|x_{1:i-1})=p_x(x)&gt;0\] <p>Since $p_x(x)&gt;0$, the determinant is also greater than zero, thus the inverse of transformation $F$ must exist. Therefore, we have</p> \[p_z(z)=p_x(x)|\det J_F(x)|^{-1}=1\] <p>i.e., $z$ follows a uniform distribution $[0,1]^D$ in $D$-dimensional space.</p> <p>From the above discussion, we can see that we can transform any distribution into a uniform distribution, and also transform a uniform distribution into any distribution. Thus, through normalizing flows, we can achieve mutual transformation between any two distributions.</p> <h2 id="continuous-normalizing-flows">Continuous Normalizing Flows</h2> <p><strong>Continuous Normalizing Flows (CNFs)</strong> are an extension of <strong>Normalizing Flows</strong> that can better model complex probability distributions. In traditional <strong>Normalizing Flows</strong>, transformations are typically defined through a series of <strong>invertible discrete functions</strong>, whereas in <strong>CNFs</strong>, these transformations are <strong>continuous</strong>, enabling the model to adapt more smoothly to data distributions and enhancing the model’s expressive power.</p> <p>In the continuous setting, <strong><em>FM</em></strong> can be formalized as follows:</p> <ul> <li> <p><strong><em>Trajectory</em></strong></p> <p>A trajectory is a mapping from time to sample position. The input is $t$, and the output is $X_t$. The domain of $t$ is $[0,1]$, and the domain of $X_t$ is $\mathbb R^d$</p> \[X:[0,1]\to \mathbb R^d,\quad t\to X_t\] <p>At $t=0$, $X_0$ comes from a simple initial distribution $p_{init}$. At time $t=1$, we want $X_1$ to follow the true data distribution $p_{data}$.</p> </li> <li> <p><strong><em>Vector Field</em></strong></p> <p>A vector field is a mapping from position and time to instantaneous velocity. The inputs are <strong><em>location</em></strong> and <strong><em>time</em></strong>, and the output is <strong><em>velocity</em></strong>.</p> \[u:\mathbb R^d\times[0,1]\to \mathbb R^d,\quad (x,t)\to u_t(x)\] <p>At any position $x$ and any time $t$, the vector field provides the direction and speed of sample transformation.</p> </li> <li> <p><strong><em>ODE</em></strong></p> <p>The trajectory $X_t$ must satisfy the following initial value problem:</p> \[\frac{d}{dt}X_t=u_t(X_t),\quad X_0=x_0\] <p>Here, $x_0\sim p_{init}$ is a sample from the initial simple distribution.</p> <p>Solving an ordinary differential equation means finding a curve $X_t$ such that its tangent velocity at each time $t$ exactly equals the value of the vector field $u_t$ at its position (i.e., the derivative of $X_t$ equals $u_t$). That is, solving this differential equation yields the path starting from $x_0$.</p> </li> <li> <p><strong><em>Flow</em></strong></p> <p>A flow is a mapping of the evolution of the initial point $x_0$ at each time, denoted as</p> \[\psi_t(x_0)=X_t\] <p>with domain $\psi:\mathbb R^d\times[0,1]\to \mathbb R^d,\quad (x_0,t)\to X_t$</p> <ul> <li> <p>The flow tells us the position of the sample at time $t$ starting from $X_0=x_0,t=0$, i.e., what $X_t$ is.</p> </li> <li> <p>The flow is the solution satisfying the above <strong><em>ODE</em></strong>: \(\frac{d}{dt}\psi_t(x_0)=u_t(\psi_t(x_0)),~\psi_0(x_0)=x_0\)</p> </li> </ul> </li> </ul> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2025-11-5-Note-FM/figure3-480.webp 480w,/assets/img/posts/2025-11-5-Note-FM/figure3-800.webp 800w,/assets/img/posts/2025-11-5-Note-FM/figure3-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/posts/2025-11-5-Note-FM/figure3.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>In practice, when using <strong><em>CNFs</em></strong>, we need to first estimate the vector field $u_t(x)$, which can be approximated by a neural network $u_t^{\theta}$. After obtaining the approximation $u_t^{\theta}$, we solve the corresponding <strong><em>ODE</em></strong> to get the trajectory $\psi_t^{\theta}(X_0)$.</p> <p>We want the sample distribution to exactly match $p_{data}$ when the model evolves to the endpoint $t=1$:</p> \[X_1=\psi_1^{\theta}(X_0)\sim p_{data}\] <p>Generally, we train $\theta$ through <strong><em>Flow Matching</em></strong> to make the evolved distribution consistent with the data distribution, i.e., to have the endpoint $X_1$ of the <strong><em>trajectory</em></strong> follow the $p_{data}$ distribution.</p> <p>After learning the vector field $u_t^{\theta}$, we need to numerically solve the $ODE$ (using first-order Euler method) to obtain $X_t$:</p> \[X_{t+h}=X_t+hu_t^{\theta}(X_t)\] <p>Below, we will focus on introducing the <strong><em>Flow Matching</em></strong> technique.</p> <h2 id="flow-matching">Flow Matching</h2> <p>An intuitive method for training <strong>Continuous Normalizing Flows</strong> is to obtain the distribution of $x_1$ by solving the <strong>ODE</strong> given initial condition $x_0$, and then constrain it to match the true data distribution using a divergence minimization measure (such as KL divergence). However, since intermediate trajectories are numerous and unknown, inferring $x_1$ (through sampling or computing likelihood) requires repeated <strong>ODE</strong> simulations, resulting in enormous computational cost. To address this, the paper proposes a new method called <strong>Flow Matching (FM)</strong>.</p> <p><strong>Flow Matching</strong> is a technique suitable for training <strong>Continuous Normalizing Flows</strong> that is <strong>Simulation-Free</strong>, meaning it does not require ODE inference of the target data distribution. <strong>Its core idea is to ensure that the dynamic characteristics between the model-predicted vector field and the vector field describing the actual motion of data points remain consistent, thereby ensuring that the final probability distribution obtained through CNFs transformation matches the expected target distribution.</strong></p> <p>Specifically, given a target probability density path $p_t(x)$ and its corresponding vector field $u_t(x)$, where the probability density path $p_t(x)$ is generated by this vector field $u_t(x)$, and $v_t(x)$ is the vector field to be learned, the <strong>Flow Matching</strong> optimization objective can be defined as:</p> \[\color{red} \mathcal L_{FM}(\theta)=\mathbb E_{t\sim U[0,1],x\sim p_t(x)}\|v_t(x)-u_t(x)\|^2\] <p>The core of the <strong>Flow Matching</strong> objective is to minimize this loss function so that its predicted vector field $v_t(x)$ is as close as possible to the actual vector field $u_t(x)$, thereby accurately generating the target probability density path $p_t(x)$.</p> <h3 id="continuity-equation">Continuity Equation</h3> <p><strong>In physics, the Continuity Equation is a partial differential equation that describes the transport behavior of conserved quantities</strong>. Under appropriate conditions, mass, energy, momentum, charge, etc., are all conserved quantities, so many transport behaviors can be described using the continuity equation.</p> \[\frac{\partial \rho}{\partial t}+\nabla \cdot (\rho v)=0\] <p>where $\rho$ is the fluid density, $v$ is the fluid velocity vector, $\frac{\partial \rho}{\partial t}$ is the rate of change of fluid density over time, and $\nabla \cdot (\rho v)$ is the divergence of the mass flux density. The meaning of this equation is: the rate of mass change within any closed volume in the fluid equals the difference between the mass flux flowing in and out of that space.</p> <p>By analogy to probability distributions, this equation can be written as:</p> \[\color{red}\frac{\partial p_t(x)}{\partial t}+\nabla \cdot (p_t(x)v_t(x))=0\] <p>In the above equation, $p_t(x)$ is the probability density function at time $t$, and $v_t(x)$ is the vector field associated with $p_t(x)$. This equation is a necessary and sufficient condition for the vector field $v_t(x)$ to generate the probability density path $p_t(x)$, and will be used as a constraint in subsequent derivations.</p> <p>For conditional probability, the above equation becomes</p> \[\frac{\partial p_t(x|x_1)}{\partial t}+\nabla \cdot (p_t(x|x_1)v_t(x|x_1))=0\] <h3 id="conditional-and-marginal-probability-paths-and-vector-fields">Conditional and Marginal Probability Paths and Vector Fields</h3> <p>Since we need to predetermine appropriate $p_t(x)$ and $u_t(x)$ during training, this is obviously difficult. However, we can start from the true distribution $q(x_1)$ and transform the true distribution into other simple distributions through invertible transformations. In this process, we can explicitly write out the <strong>conditional probability path</strong> $p_t(x|x_1)$, and according to the <strong><em>Continuity Equation</em></strong>, we can derive the conditional vector field. <strong><em>By weighting the conditional vector field and conditional probability path (density) using Bayes’ formula, we can recover the marginal probability path and marginal vector field, namely</em></strong> $p_t(x)$ <strong><em>and</em></strong> $u_t(x)$.</p> <p>Since the marginal density is the integral of the conditional density:</p> \[p_t(x)=\int p_t(x|x_1)q(x_1)dx_1\] <p>Thus, its partial derivative with respect to $t$ is:</p> \[\frac{\partial p_t(x)}{\partial t}=\int \frac{\partial p_t(x|x_1)}{\partial t}q(x_1)dx_1=-\int \nabla \cdot (p_t(x|x_1)u_t(x|x_1))q(x_1)dx_1\] <p>According to the continuity equation, if we want a vector field $u_t(x)$ to correspond to the probability path $p_t(x)$, then we must have:</p> \[-\nabla \cdot (p_t(x)u_t(x))=-\int \nabla \cdot (p_t(x|x_1)u_t(x|x_1))q(x_1)dx_1\] <p>We can solve to get</p> \[\color{red}u_t(x)=\int u_t(x|x_1)\frac{p_t(x|x_1)}{p_t(x)}q(x_1)dx_1\] <p>This means that if the marginal vector field $u_t(x)$ is given by the above equation, then it will correspondingly generate the marginal probability path $p_t(x)$.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/posts/2025-11-5-Note-FM/figure4-480.webp 480w,/assets/img/posts/2025-11-5-Note-FM/figure4-800.webp 800w,/assets/img/posts/2025-11-5-Note-FM/figure4-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/posts/2025-11-5-Note-FM/figure4.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>As shown in the figure above, computing the marginal vector field essentially performs a weighted average over all possible conditional vectors.</p> <h3 id="conditional-flow-matching">Conditional Flow Matching</h3> <p>We find that even though we have the formula for computing $u_t(x)$, the above marginal integral is still intractable, so directly optimizing the <strong><em>Flow Matching</em></strong> objective function is infeasible.</p> <p>The paper proposes the <strong>Conditional Flow Matching</strong> method. <strong>As long as</strong> $u_t(x|x_1)$ <strong>and</strong> $u_t(x)$ <strong>satisfy the above weighted marginal integral condition</strong>, the <strong>Conditional Flow Matching</strong> optimization objective has the same optimal solution as the original <strong>Flow Matching</strong> objective function. The <strong>Conditional Flow Matching</strong> optimization objective is:</p> \[\color{red} \mathcal L_{CFM}(\theta)=\mathbb E_{t\sim U[0,1],x_1\sim q(x_1),x\sim p_t(x|x_1)}\|v_t(x)-u_t(x|x_1)\|^2\] <p>The paper proves through <strong>Theorem1</strong> that the <strong>Conditional Flow Matching</strong> optimization objective and the original <strong>Flow Matching</strong> objective function have the <strong>same gradient</strong>, which means they have the <strong>same optimal solution</strong>.</p> <blockquote> <p><strong><em>Theorem1</em></strong> Assume that for all $x\in\mathbb R^d$ and $t\in [0,1]$, we have $p_t(x)&gt;0$. Then $\mathcal L_{CFM}$ and $\mathcal L_{FM}$ differ by a constant independent of $\theta$, i.e.,</p> \[\nabla _{\theta}\mathcal L_{FM}(\theta)=\nabla _{\theta}\mathcal L_{CFM}(\theta)\] <p><strong><em>Proof</em></strong></p> <p>To ensure the existence of integrals and to facilitate exchanging the order of integration (using Fubini’s theorem), we assume that $q(x)$ and $p_t(x_1)$ decay to 0 sufficiently fast as $|x|\to\infty$, and that $u_t$, $v_t$, $\nabla v_t$ are all bounded.</p> <p>First, we expand the squared norm:</p> \[\begin{align*} \|v_t(x) - u_t(x)\|^2 &amp;= \|v_t(x)\|^2 - 2 \langle v_t(x), u_t(x) \rangle + \|u_t(x)\|^2 \\ \|v_t(x) - u_t(x \mid x_1)\|^2 &amp;= \|v_t(x)\|^2 - 2 \langle v_t(x), u_t(x \mid x_1) \rangle + \|u_t(x \mid x_1)\|^2 \end{align*}\] <p>Next, note that $u_t$ is independent of $\theta$, and we have:</p> \[\begin{align*} \mathbb{E}_{p_t(x)} \|v_t(x)\|^2 &amp;= \int \|v_t(x)\|^2 p_t(x) dx \\ &amp;= \iint \|v_t(x)\|^2 p_t(x \mid x_1) q(x_1) dx_1 dx \\ &amp;= \mathbb{E}_{q(x_1), p_t(x \mid x_1)} \|v_t(x)\|^2 \end{align*}\] <p>Next, we compute:</p> \[\begin{align*} \mathbb{E}_{p_t(x)} \langle v_t(x), u_t(x) \rangle &amp;= \int \left\langle v_t(x), \int u_t(x \mid x_1) \frac{p_t(x \mid x_1) q(x_1)}{p_t(x)} dx_1 \right\rangle p_t(x) dx \\ &amp;= \int \left\langle v_t(x), \int u_t(x \mid x_1) p_t(x \mid x_1) q(x_1) dx_1 \right\rangle dx \\ &amp;= \iint \langle v_t(x), u_t(x \mid x_1) \rangle p_t(x \mid x_1) q(x_1) dx dx_1 \\ &amp;= \mathbb{E}_{q(x_1), p_t(x \mid x_1)} \langle v_t(x), u_t(x \mid x_1) \rangle \end{align*}\] <p>Meanwhile, we note that the third term in the squared norm expansion is a constant independent of $\theta$, thus proving the theorem.</p> </blockquote> <p>Based on the above discussion, the core of constructing a trainable flow model becomes how to design appropriate conditional probability paths and conditional vector fields. Generally speaking, conditional probability paths are easier to construct, while conditional vector fields are more challenging. According to the <strong><em>Continuity Equation</em></strong>, we know</p> \[\frac{\partial p_t(x|x_1)}{\partial t}+\nabla \cdot (p_t(x|x_1)v_t(x|x_1))=0\] <p>This equation allows us to explicitly compute a closed-form $v_t(x|x_1)$ when $p_t(x|x_1)$ is a Gaussian family or a simple function.</p> <h3 id="calculate-conditional-probability-paths-and-conditional-vector-fields">Calculate Conditional Probability Paths and Conditional Vector Fields</h3> <p><strong>Conditional Flow Matching</strong> can choose arbitrary conditional probability paths as long as they satisfy boundary conditions. Here, for simplicity (to obtain a closed-form conditional vector field), we analyze how to construct $p_t(x|x_1)$ and $u_t(x|x_1)$ for general <strong>Gaussian conditional probability paths</strong>.</p> <p>Assume the conditional probability path is a <strong>Gaussian probability path</strong>:</p> \[p_t(x|x_1)=\mathcal N(x|\mu_t(x_1),\sigma_T(x_1)^2I)\] <p>We impose the following constraints on this conditional probability path:</p> <p>At the beginning of time ($t=0$), we satisfy $\mu_0(x_1) = 0, \sigma_0(x_1) = 1$, ensuring that all conditional probability paths converge to the same standard Gaussian noise distribution, i.e., $p(x) = \mathcal{N}(x \mid 0, I)$.</p> <p>At the end of time ($t=1$), we satisfy $\mu_1(x_1) = x_1, \sigma_1(x_1) = \sigma_{\min}$, where $\sigma_{\min}$ should be set sufficiently small to ensure that $p(x \mid x_1)$ is a Gaussian distribution with mean $x_1$ and small variance, so that the conditional probability path converges near $x_1$.</p> <p>This setting defines a deterministic transformation process, starting from a standard Gaussian distribution at $t=0$ and gradually transforming to the target distribution at $t=1$.</p> <p>For a probability path, <strong>there exist infinitely many vector fields that can generate it</strong>, for example, by adding a divergence-free component to the <strong>Continuity Equation</strong>, but this leads to unnecessary computational cost. Here we can use the simplest vector field, <strong>which corresponds to the standard transformation of a Gaussian distribution, with the corresponding data point Flow Map being</strong>:</p> \[x_t=\psi_t(x)=\sigma_t(x_1)x+\mu_t(x_1)\] <p>where $x\sim\mathcal N(0,1)$. $\psi_t(x)$ is an affine transformation that maps $x$ to a normal random variable with mean $\mu_t(x_1)$ and standard deviation $\sigma_t(x_1)$. That is, according to Equation 4, $\psi_t$ pushes the noise distribution $p_0(x|x_1) = p(x)$ to $p_t(x|x_1)$, i.e.,</p> \[\begin{equation} [\psi_t]_∗ p(x) = p_t(x|x_1). \end{equation}\] <p>The flow further defines a vector field that generates the conditional probability path:</p> \[\begin{equation} \frac{d}{dt} \psi_t(x) = u_t(\psi_t(x) \mid x_1). \end{equation}\] <p>Reparametrizing $p_t(x|x_1)$ in terms of $x_0$ and substituting into Equation (13), we obtain the CFM loss function as follows:</p> \[\begin{equation} \mathcal{L}_{\text{CFM}}(\theta) = \mathbb{E}_{t, q(x_1), p(x_0)} \left\| v_t(\psi_t(x_0)) - \frac{d}{dt} \psi_t(x_0) \right\|^2. \end{equation}\] <p>Since $\psi_t$ is a simple (invertible) affine mapping, we can utilize Equation (13) to obtain a closed-form solution for $u_t$. Let $f’$ denote the derivative with respect to time $t$, i.e., $f’ = \frac{d}{dt} f$, where $f$ is a time-dependent function.</p> <blockquote> <p><strong><em>Theorem2</em></strong> Let $p_t(x|x_1)$ be the Gaussian probability path as defined in Equation 10, and $\psi_t$ be its corresponding flow map as described in Equation 11. Then the vector field that uniquely defines $\psi_t$ has the following form:</p> \[u_t(x|x_1) = \frac{\sigma'_t(x_1)}{\sigma_t(x_1)} \left( x - \mu_t(x_1) \right) + \mu'_t(x_1)\] <p>Therefore, $u_t(x|x_1)$ generates the Gaussian path $p_t(x|x_1)$</p> <p><strong><em>Proof:</em></strong></p> <p>For notational brevity, let $w_t(x) = u_t(x|x_1)$. Now consider Equation 1:</p> \[\frac{d}{dt}\psi_t(x) = w_t(\psi_t(x)).\] <p>Since $\psi_t$ is invertible (because $\sigma_t(x_1) &gt; 0$), we set $x = \psi_t^{-1}(y)$ and obtain</p> \[\psi_t'(\psi_t^{-1}(y)) = w_t(y)\] <p>Here we use prime notation to denote derivatives, emphasizing that $\psi_t’$ is evaluated at $\psi_t^{-1}(y)$.</p> <p>Now, inverting $\psi_t(x)$ yields</p> \[\psi_t^{-1}(y) = \frac{y - \mu_t(x_1)}{\sigma_t(x_1)}.\] <p>Taking the derivative of $\psi_t$ with respect to $t$ yields</p> \[\psi_t'(x) = \sigma_t'(x_1)x + \mu_t'(x_1).\] <p>Substituting these last two equations into the second line, we obtain</p> \[w_t(y) = \frac{\sigma_t'(x_1)}{\sigma_t(x_1)}(y - \mu_t(x_1)) + \mu_t'(x_1).\] </blockquote> <h2 id="special-instances-of-gaussian-conditional-probability-paths">Special Instances of Gaussian Conditional Probability Paths</h2> <h3 id="diffusion-conditional-vfs">Diffusion conditional VFs</h3> <p><strong>Variance Exploding (VE) and Variance Preserving (VP)</strong> in diffusion models are two different types of diffusion processes used in generative models to simulate two different data distribution change processes.</p> <h4 id="variance-exploding-ve">Variance Exploding (VE)</h4> <p>The VE diffusion model is a diffusion process that increases data variance during the generation process. In this model, as time progresses, data samples gradually become more noisy, with variance continuously increasing until reaching a stable state. A characteristic of the VE process is that it allows the model to explore a wider latent space when generating data, which helps generate diverse samples.</p> <p>The conditional probability path for VE is:</p> \[p_t(x | x_1) = \mathcal{N}(x | x_1, \sigma_{1-t}^2 I)\] <p>where $\sigma_t$ is an increasing function, $\sigma_0 = 0, \sigma_1 \gg 1$, corresponding to mean and standard deviation</p> \[\mu_t(x_1) = x_1, \quad \sigma_t(x_1) = \sigma_{1-t}\] <p>According to Theorem 3, the conditional vector field can be computed as:</p> \[u_t(x | x_1) = - \frac{\sigma'_{1-t}}{\sigma_{1-t}}(x - x_1)\] <h4 id="variance-preserving-vp">Variance Preserving (VP)</h4> <p>The VP diffusion model is a diffusion process that keeps data variance constant during the generation process. In this model, the variance of data samples remains constant throughout the generation process, meaning that while the model introduces noise, it also reduces noise in some way to maintain the overall variance of the data. VP models are typically used in application scenarios that require maintaining data distribution stability, such as maintaining image clarity and structural features in image generation.</p> <p>The conditional probability path for VP is:</p> \[p_t(x | x_1) = \mathcal{N}\left(x \mid \alpha_{1-t}x_1, (1 - \alpha_{1-t}^2)I\right) \text{, where } \alpha_t = e^{-\frac{1}{2}T(t)}, T(t) = \int_0^t \beta(s)ds\] <p>where $\alpha, \beta$ are noise schedule functions, corresponding to mean and standard deviation</p> \[\mu_t(x_1) = \alpha_{1-t}x_1, \quad \sigma_t(x_1) = \sqrt{1 - \alpha_{1-t}^2} \,。\] <p>According to Theorem 3, the conditional vector field can be computed as:</p> \[\begin{align*} u_t(x | x_1) &amp;= \frac{\alpha'_{1-t}}{1-\alpha_{1-t}^2}(\alpha_{1-t}x - x_1) \\ &amp;= -\frac{T'(1-t)}{2}\left[ \frac{e^{-T(1-t)}x - e^{-\frac{1}{2}T(1-t)}x_1}{1-e^{-T(1-t)}} \right] \end{align*}\] <h3 id="optimal-transport-conditional-vfs">Optimal Transport conditional VFs</h3> <p>Optimal Transport (OT) chooses to define the mean and standard deviation of the conditional probability path as simple linear functions. As time $t: 0 \to 1$, corresponding to the probability density path from $p(x) = \mathcal{N}(x | 0, I)$ to $p_1(x | x_1)$, the mean and standard deviation are defined as:</p> \[\mu_t(x_1) = tx_1, \quad \text{and} \quad \sigma_t(x_1) = 1 - (1 - \sigma_{\min})t\] <p>Then the corresponding Flow Map is:</p> \[\psi_t(x) = (1 - (1 - \sigma_{\min})t)x + tx_1\] <p>According to Theorem 3, the closed-form solution of the conditional vector field can be computed as:</p> \[u_t(x | x_1) = \frac{x_1 - (1 - \sigma_{\min})x}{1 - (1 - \sigma_{\min})t}\] <p><strong><em>Optimal transport paths are straight lines, whereas diffusion paths are curves, thus achieving faster training and generation speeds, as well as better performance.</em></strong></p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> <d-article> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/2025-11-07-Note-AR2Diff/"></a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/Note-Diffusion-DDPM-and-NCSN/">The Unification of DDPM and Score-based Models</a> </li> <br> <br> <div id="giscus_thread"> <script defer src="/assets/js/giscus-setup.js"></script> <noscript> Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </d-article> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 R. Z. Tian. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script src="/assets/js/distillpub/overrides.js"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?e510a9b2408214d7071a1c65feace861"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>